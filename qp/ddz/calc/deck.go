package calc

import (
	"github.com/znyh/class/qp/base"
)

/*
	一副牌定义 （54张）
*/

var (
	oneCards = []int32{
		0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, //方块
		0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, //梅花
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, //红桃
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, //黑桃
		0x4e, 0x4f,
	}

	descCards = map[int32]string{
		0x01: "方块A", 0x02: "方块2", 0x03: "方块3", 0x04: "方块4", 0x05: "方块5", 0x06: "方块6", 0x07: "方块7", 0x08: "方块8", 0x09: "方块9", 0x0a: "方块10", 0x0b: "方块J", 0x0c: "方块Q", 0x0d: "方块K",
		0x11: "梅花A", 0x12: "梅花2", 0x13: "梅花3", 0x14: "梅花4", 0x15: "梅花5", 0x16: "梅花6", 0x17: "梅花7", 0x18: "梅花8", 0x19: "梅花9", 0x1a: "梅花10", 0x1b: "梅花J", 0x1c: "梅花Q", 0x1d: "梅花K",
		0x21: "红桃A", 0x22: "红桃2", 0x23: "红桃3", 0x24: "红桃4", 0x25: "红桃5", 0x26: "红桃6", 0x27: "红桃7", 0x28: "红桃8", 0x29: "红桃9", 0x2a: "红桃10", 0x2b: "红桃J", 0x2c: "红桃Q", 0x2d: "红桃K",
		0x31: "黑桃A", 0x32: "黑桃2", 0x33: "黑桃3", 0x34: "黑桃4", 0x35: "黑桃5", 0x36: "黑桃6", 0x37: "黑桃7", 0x38: "黑桃8", 0x39: "黑桃9", 0x3a: "黑桃10", 0x3b: "黑桃J", 0x3c: "黑桃Q", 0x3d: "黑桃K",
		0x4e: "小王", 0x4f: "大王",
	}
)

const (
	HandCardsCount = 17 //默认手牌数
)

func OneDeck() []int32 {
	tmp := base.SliceCopy(oneCards)
	return tmp
}

// 校验是否是一副完整的牌(54张)
func IsOneDeck(seqs []int32) bool {
	return base.SliceSortEqual(OneDeck(), seqs)
}

// 校验是否是一副完整的牌(17+17+17+3 = 54张)
func CheckDeck(a, b, c, d []int32) bool {
	if ok := len(a) == 17 && len(b) == 17 && len(c) == 17 && len(d) == 3; !ok {
		return false
	}
	seqs := []int32(nil)
	seqs = append(seqs, a...)
	seqs = append(seqs, b...)
	seqs = append(seqs, c...)
	seqs = append(seqs, d...)

	return IsOneDeck(seqs)
}
